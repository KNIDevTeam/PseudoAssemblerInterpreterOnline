{
    "index": {
        "siteTitle": "Interpreter - Strona główna",
        "title": "Interpreter",
        "nav": "Strona główna",
        "run": "START",
		"prev": "&larr; Wstecz",
		"next": "Dalej &rarr;",
		"typeSth": "Wpisz coś tutaj...",
		"exampleProgram": "#Przykładowy program\nVAR1 DC INTEGER(1)\nVAR2 DC INTEGER(2)\nRES DS INTEGER\n#Wyczyść pierwszy rejestr\nSR 1,1\n#Oblicz sumę\nA 1,VAR1\nA 1,VAR2\n#Zapisz wynik w pamięci\nST 1,RES"
    },
    "docs": {
        "siteTitle": "Interpreter - Dokumentacja",
        "title": "Dokumentacja",
        "nav": "Dokumentacja",
		"general": {
			"header": "Wstęp",
			"content": "Pseudoassembler jest językiem niezwykle potężnym. Biegłe posługiwanie się nim w swoich programach jest sztuką, którą posiadło niewielu. Mamy nadzieję, że poniższa dokumentacja pozwoli Ci nie tylko docenić niezwykły kunszt programowania w językach niskopoziomowych, ale również polubić pseudoassemblera (na naszym przykładzie - to możliwe)!"
		},
		"memory": {
			"header": "Adresacja pamięci",
			"content": "W pseudoassemblerze dostępne są 4 sposoby adresowania komórek pamięci: <p></p> <ul><li><b>[etykieta]</b> - Interpreter odwoła się do komórki przypisanej do podanej etykiety. Jeżeli etykieta jest powiązana z tablicą, to wskazuje na jej pierwszy element.</li><li><b>[etykieta]([rejestr])</b> - Interpreter odwoła się do komórki, której adres jest sumą: adresu, na który wskazuje etykieta oraz adresu przechowywanego w podanym rejestrze.</li><li><b>[adres komórki]</b> - Interpreter odwoła się do komórki, która znajduje się pod podanym adresem pamięci. </li><li><b>[adres komórki]([rejestr])</b> - Interpreter odwoła się do komórki, której adres jest sumą: podanego adresu oraz adresu przechowywanego w podanym rejestrze.</li></ul><p>Wszystkie te sposoby realizują jednak to samo zadanie - dostęp do komórki pamięci.</p><h4>Przykład</h4><p>Załóżmy, że mamy zadeklarowane dwie tablice VEC1{1,2} oraz VEC2{3,4} (obie składające się z 2 zmiennych typu integer).<br>Dodatkowo przygotowaliśmy również rejestry REG1{0} oraz REG2{4}. (Zwróć uwagę, że 4 to rozmiar zmiennej typu integer zapisany w bajtach)<br>Przeanalizujmy teraz adresy pamięci wykorzystywane przez nasze zmienne:<pre>VEC1[0] = 1 | adres: 0<br>VEC1[1] = 2 | adres: 4<br>VEC2[0] = 3 | adres: 8<br>VEC2[1] = 4 | adres: 12</pre>Poniższy program obliczy sumę wartości zapisanych w tablicach VEC1 i VEC2, po czym zapisze wynik do rejestru REG1:<p></p><pre>A   1, VEC1<br>A   1, VEC1(2)<br>A   1, 8 <br>A   1, 8(2)</pre></p>"
		},
		"rules": {
			"header": "Zasady tworzenia etykiet",
			"content": "Pseudoassembler, pomimo swojej potęgi, ma pewne, niewielkie ograniczenia. Tworząc programy należy mieć na uwadze poniższe zasady: <ul><li>Etykiety mogą składać się wyłącznie ze znaków alfanumerycznych (liter A-Z, a-z oraz cyfr 0-9).</li><li>Zabronione jest wykorzystywanie poleceń pseudoassemblera jako etykiet.</li><li>Zabronione jest rozpoczynanie etykiety od cyfry.</li></ul>"
		},
		"statusRegister": {
			"header": "Rejestr stanu programu",
			"content": "Rejestr stanu programu to specjalny rejestr, który przechowuje rezultat działania programu. W zależności od znaku ostatniej operacji arytmetycznej (takiej jak: A, AR, S, SR, M, MR, D, DR, C, CR), rejestr stanu programu może przyjmować wartości:<p></p><ul><li>00 \u2013 gdy wynik jest równy 0, <\/li><li>01 \u2013 gdy wynik jest dodatni, <\/li><li>10 \u2013 gdy wynik jest ujemny, <\/li><li>11 \u2013 gdy nastąpił błąd (przykładowo usiłowano podzielić przez 0).<\/li><\/ul><h4>Przykład<\/h4>Załóżmy, że mamy przygotowane trzy rejestry: REG1{2}, REG2{-2}, REG3{0}. Przeanalizujmy stan rejestrów po wykonaniu poniższych instrukcji: <p></p><pre>AR\t1, 2\t# Rejestr stanu programu = '00'<\/pre><pre>SR\t1, 2\t# Rejestr stanu programu = '01' <\/pre><pre>MR\t1, 2\t# Rejestr stanu programu = '10' <\/pre><pre>DR\t1, 3\t# Rejestr stanu programu = '11' <\/pre>W razie wątpliwości dotyczących wykorzystanych w przykładzie komend, sprawdź rozdział poświęcony komendom pseudoassemblera."
		},
		"commands": {
			"header": "Komendy",
			"content": {
				"DS": {
					"short": "Deklaracja zmiennej lub tablicy bez wartości początkowej.",
					"long": "Komenda „DS” (Declare Space) rezerwuje wymagane miejsce w pamięci dla nowej zmiennej lub tablicy i przypisuje do niego podaną etykietę.",
					"params": "<pre>[etykieta] DS [typ zmiennej]\t\t# Deklarowanie zmiennej</pre><pre>[etykieta] DS [rozmiar]*[typ zmiennej]\t# Deklarowanie tablicy</pre>Obecnie jedynym obsługiwanym typem zmiennej jest INTEGER.",
					"examples": "Przeanalizujmy krótki przykład: <pre>ZMIENNA1\tDC\tINTEGER</pre><pre>TABLICA1\t\tDC\t3*INTEGER</pre>Po wykonaniu poniższych instrukcji, stworzone zostaną następujące obiekty:<pre>ZMIENNA1 = ?,  TABLICA1 = {?, ?, ?}. </pre><b>Zwróć uwagę, że wszystkie początkowe wartości zmiennych stworzonych komendą „DS” są nieznane (zwykle losowe)! W żadnym wypadku nie należy wykorzystywać tych zmiennych bez przypisania im wartości.</b>"
				},
				"DC": {
					"short": "Deklaracja zmiennej lub tablicy z wartością początkową.",
					"long": " Komenda „DC” (Declare Constant) rezerwuje wymagane miejsce w pamięci dla nowej zmiennej lub tablicy i przypisuje do niego podaną etykietę. W przeciwieństwie do komendy „DS” deklarowana zmienna posiada początkową wartość umieszczoną jako argument komendy.",
					"params": "<pre>[etykieta] DC [typ zmiennej]([wartość początkowa])\t\t# Deklarowanie zmiennej</pre><pre>[etykieta] DC [rozmiar]*[typ zmiennej]([wartość początkowa])\t# Deklarowanie tablicy</pre> Obecnie jedynym obsługiwanym typem zmiennej jest INTEGER.",
					"examples": "Przeanalizujmy krótki przykład: <pre>ZMIENNA1\tDC\tINTEGER(7)</pre><pre>TABLICA1\t\tDC\t3*INTEGER(12)</pre> Po wykonaniu poniższych instrukcji, stworzone zostaną następujące obiekty:<pre>ZMIENNA1 = 7,</pre><pre>TABLICA1 = {12, 12, 12}.</pre>"
				},
				"AR": {
					"short": "Dodawanie zawartości rejestrów.",
					"long": "Komenda „AR” dodaje zawartość dwóch rejestrów i zapisuje wynik tej operacji w docelowym rejestrze.",
					"params": "[etykieta] AR [rejestr docelowy], [rejestr źródłowy]",
					"examples": "Załóżmy, że mamy przygotowane rejestry: REG1{2} oraz REG2{3}. Przeanalizujmy wynik wykonania poniższej instrukcji:<pre>\tAR\t1, 2\t# REG1 = 5 (REG1 := REG1 + REG2), REG2 = 3</pre>"
				},
				"A": {
					"short": "Dodawanie zawartości rejestru i komórki pamięci.",
					"long": "Komenda „A” dodaje zawartość rejestru i komórki pamięci, po czym zapisuje wynik tej operacji w docelowym rejestrze.",
					"params": "[etykieta] A [rejestr docelowy], [źródłowa komórka pamięci] <p> Zauważ, że możliwe jest wykorzystanie czterech różnych sposobów adresacji pamięci jako [źródłowa komórka pamięci]. W razie wątpliwości sprawdź rozdział „Adresacja pamięci”.</p>",
					"examples": "Załóżmy, że zadeklarowaliśmy zmienną VAR{2} i przygotowaliśmy rejestr REG1{-1}. Przeanalizujmy wynik działania poniższej instrukcji:<pre>\tA\t1, VAR\t# REG1 = 1</pre>"
				},
				"SR": {
					"short": "Odejmowanie zawartości rejestrów.",
					"long": "Komenda „SR” odejmuje zawartość drugiego rejestru od zawartości pierwszego rejestru i zapisuje wynik tej operacji w docelowym rejestrze.",
					"params": "[etykieta] SR [rejestr docelowy], [rejestr źródłowy]",
					"examples": "Załóżmy, że mamy przygotowane rejestry: REG1{-12} oraz REG2{4}. Przeanalizujmy wynik wykonania poniższej instrukcji:<pre>\tSR\t1, 2\t# REG1 = -16 (REG1 := REG1 - REG2), REG2 = 4</pre>"
				},
				"S": {
					"short": "Odejmowanie zawartości rejestru i komórki pamięci.",
					"long": "Komenda „S” odejmuje zawartość komórki pamięci od zawartości rejestru, po czym zapisuje wynik tej operacji w docelowym rejestrze.",
					"params": "[etykieta] S [rejestr docelowy], [źródłowa komórka pamięci] <p> Zauważ, że możliwe jest wykorzystanie czterech różnych sposobów adresacji pamięci jako [źródłowa komórka pamięci]. W razie wątpliwości sprawdź rozdział „Adresacja pamięci”.</p>",
					"examples": "Załóżmy, że zadeklarowaliśmy zmienną VAR{14} i przygotowaliśmy rejestr REG1{3}. Przeanalizujmy wynik działania poniższej instrukcji:<pre>\tS\t1, VAR\t# REG1 = 11</pre>"
				},
				"MR": {
					"short": "Mnożenie zawartości rejestrów.",
					"long": "Komenda „MR” mnoży zawartość dwóch rejestrów i zapisuje wynik tej operacji w docelowym rejestrze.",
					"params": "[etykieta] MR [rejestr docelowy], [rejestr źródłowy]",
					"examples": "Załóżmy, że mamy przygotowane rejestry: REG1{4} oraz REG2{6}. Przeanalizujmy wynik wykonania poniższej instrukcji:<pre>\tMR\t1, 2\t# REG1 = 24 (REG1 := REG1 * REG2), REG2 = 6</pre>"
				},
				"M": {
					"short": "Mnożenie zawartości rejestru i komórki pamięci.",
					"long": "Komenda „M” mnoży zawartość rejestru i komórki pamięci, po czym zapisuje wynik tej operacji w docelowym rejestrze.",
					"params": "[etykieta] M [rejestr docelowy], [źródłowa komórka pamięci] <p> Zauważ, że możliwe jest wykorzystanie czterech różnych sposobów adresacji pamięci jako [źródłowa komórka pamięci]. W razie wątpliwości sprawdź rozdział „Adresacja pamięci”.</p>",
					"examples": "Załóżmy, że zadeklarowaliśmy zmienną VAR{2} i przygotowaliśmy rejestr REG1{8}. Przeanalizujmy wynik działania poniższej instrukcji:<pre>\tM\t1, VAR\t# REG1 = 16</pre>"
				},
				"DR": {
					"short": "Dzielenie zawartości rejestrów.",
					"long": "Komenda „DR” dzieli zawartość pierwszego rejestru przez zawartość drugiego rejestru i zapisuje wynik tej operacji w docelowym rejestrze.",
					"params": "[etykieta] DR [rejestr docelowy], [rejestr źródłowy]",
					"examples": "Załóżmy, że mamy przygotowane rejestry: REG1{8} oraz REG2{2}. Przeanalizujmy wynik wykonania poniższej instrukcji:<pre>\tDR\t1, 2\t# REG1 = 4 (REG1 := REG1 / REG2), REG2 = 2</pre> <p>Przeanalizujmy teraz inny przykład: REG3{2}, REG4{0}. Wynik wykonania poniższej instrukcji to:<pre>\tDR\t3, 4\t# REG3 = 2, REG4 = 0, Rejestr stanu programu = '11'</pre></p>"
				},
				"D": {
					"short": "Dzielenie zawartości rejestru i komórki pamięci.",
					"long": "Komenda „D” dzieli zawartość rejestru przez zawartość komórki pamięci, po czym zapisuje wynik tej operacji w docelowym rejestrze.",
					"params": "[etykieta] D [rejestr docelowy], [źródłowa komórka pamięci] <p> Zauważ, że możliwe jest wykorzystanie czterech różnych sposobów adresacji pamięci jako [źródłowa komórka pamięci]. W razie wątpliwości sprawdź rozdział „Adresacja pamięci”.</p>",
					"examples": "Załóżmy, że zadeklarowaliśmy zmienną VAR{2} i przygotowaliśmy rejestr REG1{3}. Przeanalizujmy wynik działania poniższej instrukcji:<pre>\tD\t1, VAR\t# REG1 = 1</pre>"
				},
				"C": {
					"short": "Porównanie zawartości rejestru i komórki pamięci",
					"long": "“C” command compares content of register and memory block by subtracting content of register and content of memory block. Depending on the sign of the result of this subtraction, status register is changed. content of register and memory block won’t change.",
					"params": "[etykieta] C [register], [memory block] <p> Note that you can choose from four different ways of addressing using [memory block]. Look at “Memory addressing” section for further assistance.</p>",
					"examples": " Suppose we declared variable VAR{2} and prepared register REG1{2}. Now let's analyse the result of executing the following code: <pre>\tC\t1, VAR\t# Status register = '00'</pre>"
				},
				"CR": {
					"short": "Porównanie zawartości rejestrów.",
					"long": "“CR” command compares content of two registers by subtracting content of first register and content of second register. Depending on the sign of the result of this subtraction, status register is changed. content of both registers won’t change.",
					"params": "[etykieta] CR [first register], [second register]",
					"examples": "Suppose we have already prepared registers – REG1{2} and REG2{3}. Let’s analyse the result of following operation: <pre>\tCR\t1, 2\t# Status register = '10'</pre>"
				},
				"J": {
					"short": "Bezwarunkowy skok do linii programu opatrzonej etykietą.",
					"long": "“J” command unconditionally jumps to program line with provided label. It’s useful for designing loops or default actions in if-like conditions.",
					"params": "[etykieta] J [target label]",
					"examples": " Suppose we declared variable VAR{1} and prepared register REG1{0}. Now let's analyse the result of executing the following code: <pre>START\tA\t1, VAR\t# REG1 = 1 </pre><pre>\tA\t1, VAR\t# REG1 = 2 </pre><pre>JUMP\tJ\tEND\t</pre><pre>\tA\t1, VAR\t</pre><pre>\tA\t1, VAR\t</pre><pre>END\tST\t1, VAR\t# VAR1 = 2</pre>"
				},
				"JZ": {
					"short": "Skok do linii programu opatrzonej etykietą jeśli wynik poprzedniej operacji jest równy 0.",
					"long": "“JZ” command jumps to program line with provided label depending upon the condition. If the result of last operation is equal to 0 (status register = “00”) a jump to target line would be performed. It’s useful for designing loops or if-like conditions.",
					"params": "[etykieta] JZ [target label]",
					"examples": " Suppose we declared variable VAR{1} and prepared registers REG1{0} and REG2{3}. Now let's analyse the result of executing the following code: <pre>START\tAR\t1, 2</pre><pre>\tS\t2, VAR\t# Note that status register value may change.</pre><pre>JUMP\tJZ\tEND\t</pre><pre>\tJ\tSTART</pre><pre>END\tST\t1, VAR\t# VAR1 = 6</pre>"
				},
				"JP": {
					"short": "Skok do linii programu opatrzonej etykietą jeśli wynik poprzedniej operacji jest dodatni.",
					"long": "“JP” command jumps to program line with provided label depending upon the condition. If the result of last operation is positive (status register = “01”) a jump to target line would be performed. It’s useful for designing loops or if-like conditions.",
					"params": "[etykieta] JP [target label]",
					"examples": " Suppose we declared variable VAR{1} and prepared registers REG1{0} and REG2{-4}. Now let's analyse the result of executing the following code: <pre>START\tAR\t1, 2</pre><pre>\tA\t2, VAR\t# Note that status register value may change.</pre><pre>JUMP\tJP\tEND\t</pre><pre>\tJ\tSTART</pre><pre>END\tST\t1, VAR\t# VAR1 = -10</pre>"
				},
				"JN": {
					"short": "Skok do linii programu opatrzonej etykietą jeśli wynik poprzedniej operacji jest ujemny.",
					"long": "“JN” command jumps to program line with provided label depending upon the condition. If the result of last operation is negative (status register = “10”) a jump to target line would be performed. It’s useful for designing loops or if-like conditions.",
					"params": "[etykieta] JN [target label]",
					"examples": " Suppose we declared variable VAR{1} and prepared registers REG1{0} and REG2{2}. Now let's analyse the result of executing the following code: <pre>START\tAR\t1, 2</pre><pre>\tS\t2, VAR\t# Note that status register value may change.</pre><pre>JUMP\tJN\tEND\t</pre><pre>\tJ\tSTART</pre><pre>END\tST\t1, VAR\t# VAR1 = 2 (2 + 1 + (-1))</pre>"
				},
				"L": {
					"short": "Wczytanie zawartości komórki pamięci do rejestru.",
					"long": "“L” command loads content of memory block to target register. Note that it is possible to load value of an undefined variable (created using DS command) – resulting value would probably be random.",
					"params": "[etykieta] L [rejestr docelowy], [źródłowa komórka pamięci] <p> Note that you can choose from four different ways of addressing using [źródłowa komórka pamięci]. Look at “Memory addressing” section for further assistance.</p>",
					"examples": " Suppose we declared variable VAR{1} and prepared register REG1. Now let's analyse the result of executing the following code: <pre>L\t1, VAR\t# REG1 = 1</pre>"
				},
				"LR": {
					"short": "Wczytanie zawartości źródłowego rejestru do docelowego rejestru.",
					"long": "“LR” command loads content of of source register to target register. Note that it is possible to load value of an undefined register – resulting value would probably be random.",
					"params": "[etykieta] LR [rejestr docelowy], [rejestr źródłowy]",
					"examples": " Suppose prepared registers REG1{3}, REG2{4}. Now let's analyse the result of executing the following code: <pre>LR\t2, 1\t# REG2 = 3, REG1 = 3</pre>"
				},
				"LA": {
					"short": "Wczytanie adresu komórki pamięci do docelowego rejestru.",
					"long": "Komenda “LA” wczytuje adres komórki pamięci do docelowego rejestru. Jest używana głónie do iterowania po tablicy w pętli.",
					"params": "[etykieta] LA [docelowy rejestr], [komórka pamięci] <p> Należy zauważyć że użytkownik może korzystać z różnych sposobów adresowania. Więcej na ten temat można znaleźć w sekcji “Adresacja pamięci”.</p>",
					"examples": " Załóżmy że mamy przygotowane komórki pamięci oraz tablicę: VAR1, VAR2, ARR1[3] a także rejestr REG1. Przeanalizujmy wynik wykonania następującej lini kodu: <pre>LA\t1, ARR1\t# REG1 = 8</pre>"
				},
				"ST": {
					"short": "Wczytanie zawartości źródłowego rejestru do docelowej komórki pamięci",
					"long": "“ST” Komenda wczytuje zawartość źródłowego rejestru do docelowej komórki pamięci. Należy pamiętać że możliwym jest wczytanie wartości z niezdefiniowanego rejestru – w rezultacie wartość ta będzie prawdopodobnie przypadkowa. <p><b>Komenda “ST” jest jedyną komendą w psseudoassemblerze której drugi argument jest argumentem docelowym (ARG1 → ARG2). Dla wszystkich komend poza “ST” mamy: ARG1 ← ARG2. </b></p>",
					"params": "[etykieta] ST [źródłowy rejestr], [docelowa komórka pamięci] <p> Należy zauważyć że użytkownik może korzystać z różnych sposobów adresowania. Więcej na ten temat można znaleźć w sekcji “Adresacja pamięci”.</p>",
					"examples": " Załóżmy że mamy przygotowaną komórkę RESULT oraz rejestr REG1{1}. Przeanalizujmy wynik wykonania następującej lini kodu: <pre>ST\t1, RESULT\t# RESULT = 1</pre>"
				}
			}
		}
    },
    "contact": {
        "siteTitle": "Interpreter - Kontakt",
        "title": "Kontakt",
        "nav": "Kontakt",
		"contact": "Kontakt",
		"authors": "Autorzy",
		"authors-long": "<ul><li><a href=\"http:\/\/razormeister.pl/site/\" target=\"_BLANK\"> Tymoteusz Bartnik</a> (Frontend oraz silnik - „dobry duch” projektu )</li><li><a href=\"https:\/\/github.com/lavar3l\" target=\"_BLANK\"> Przemysław Dominikowski</a> (Infrastruktura sieciowa – domeny, hosting; Stworzenie dokumentacji)</li><li><a href=\"https:\/\/dvalim.github.io/\" target=\"_BLANK\"> Dawid Alimowski</a> (Frontend - wygląd i układ strony, edytor, wyświetlanie wyniku działania interpretera)</li><li><a href=\"https:\/\/github.com/witek0509x\" target=\"_BLANK\"> Wojciech Drochomirecki</a> (Stworzenie silnika interpretera – parser, moduł wykonawczy)</li></ul>",
		"credits": "Podziękowania",
		"credits-long": "Chcielibyśmy podziękować wszystkim osobom, których działania i pomysły pomogły nam w stworzeniu tego projektu. Szczególne podziękowania należą się: <ul><li><a href=\"http:\/\/www.mini.pw.edu.pl/~homenda/\" target=\"_BLANK\"> prof. dr hab. inż. Władysławowi Homendzie</a> - autorowi języka pseudoassemblera, koordynatorowi projektu interpretera (napisanego w języku C) na Wydziale Matematyki i Nauk Informacyjnych Politechniki Warszawskiej - </li><li><a href=\"https:\/\/html5up.net\" target=\"_BLANK\">HTML5UP</a> - autorowi szablonu strony</li></ul>",
		"repo": "Repozytorium projektu w serwisie GitHub"
    },
	"run": {
		"program": "Program",
		"backToEditor": "Powrót",
		"registers": {
			"header": "Rejestry",
			"address": "Adres",
			"value": "Wartość",
			"state": "STAN"
		},
		"memory": {
			"header": "Pamięć",
			"address": "Adres",
			"var": "Zmienna",
			"value": "Wartość"
		}
	},	
	"examples": {
		"siteTitle": "Intepreter - Przykłady",
		"title": "Przykłady",
		"nav": "Przykłady"
	},
	"examples": {
		"siteTitle": "Intepreter - Examples",
		"title": "Przykłady",
		"nav": "Przykłady",
		"programs": {
			"test": {
				"title": "This is a test program",
				"desc": "This is a description for our test program ;D",
				"code": "#I to jest testowy kod\nMaslo DS INTEGER(3)\nCebula DC INTEGER\n#Zrób coś\nL 1, Maslo\n#Jesteśmy zgubieni [*]"
			},
			"test2": {
				"title": "This is a test program",
				"desc": "This is a description for our test program ;D",
				"code": "#And this is a code\nMaslo DS INTEGER(3)\nCebula DC INTEGER\n#Do sth\nL 1, Maslo\n#This is the end [*]"
			},
			"test3": {
				"title": "This is a test program",
				"desc": "This is a description for our test program ;D",
				"code": "#And this is a code\nMaslo DS INTEGER(3)\nCebula DC INTEGER\n#Do sth\nL 1, Maslo\n#This is the end [*]"
			}
		}
	}
}
